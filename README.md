# Микрофронтенды #
Распространение идеи микросервисов на фронтенд-разработку.
перевод [статьи Майкла Гирса](https://micro-frontends.org/)

Техники, стратегии и решения для разработки современных веб-приложений с участием нескольких команд, способных реализовывать фичи независимо друг от друга.

## Что такое микрофронтенды? ##
Термин микрофронтенды (Micro Frontends) впервые появился в конце 2016 года, на [радаре технологий ThoughtWorks](https://www.thoughtworks.com/radar/techniques/micro-frontends). Он расширял концепцию микросервисов на мир фронтенда. Сейчас уже популярен тренд, при котором single-page приложения взаимодействуют с бэком, построенном на принципах микросервисной архитектуры. При этом сам клиентский код, часто разрабатываемый отдельной командой, со временем всё больше разрастается и его становится трудно поддерживать. Именно его мы называем [монолитом фронтенда](https://www.youtube.com/watch?v=pU1gXA0rfwc&ab_channel=microXchg).

Идея микрофронтендов заключается в восприятии сайта или веб-приложения как композиции фичей, которые разрабатывают отдельные команды. Каждая команда имеет четко определенную зону ответственности в функционале приложения и специализируется на ней. При этом сами команды универсальны, работают full-stack и реализуют свои фичи end-to-end, от базы данных до пользовательского интерфейса.

Впрочем, эта идея не нова. Они имеет много общего с концепцией [автономных систем](https://scs-architecture.org/)(Self-contained Systems). Раньше аналогичный подход уже появлялся под названием [“клиентская интеграция для вертикализированных систем”](https://www.otto.de/jobs/technology/techblog/artikel/scaling-with-microservices-and-vertical-decomposition_2014-07-29.php) (Frontend Integration for Verticalised Systems). Однако термин микрофронтенды менее громоздкий и гораздо дружелюбней.

Монолитные фронтенды
![monolith-frontback-microservices](https://github.com/Pashua85/microfrontends/raw/master/images/monolith-frontback-microservices.png)

Организация по вертикали
![verticals-headline](https://github.com/Pashua85/microfrontends/raw/master/images/verticals-headline.png)

## Что такое современное веб-приложение? ##

Во вступлении я использовал фразу “разработка современных веб-приложений”. Давайте определимся, что мы под этим понятием подразумеваем.

[Эрал Бэлкон](https://ar.al/) (Aral Balcan) рассмотрел этот вопрос шире, написал отдельный пост под названием [Document-to-Application Contimuum](https://ar.al/notes/the-documents-to-applications-continuum/). Он выдвинул идею представления всего множества страниц в интернете в качестве нарисованного горизонтально отрезка со шкалой, на левом конце которого будут сайты, представляющие из себя статичные документы, соединенные друг с другом ссылками, а на другом - приложения без собственного контента, чье состояние полностью определяется поведением пользователя, например, онлайн-редактор фотографий.

Если бы вы разместили свой свой проект на левой стороне спектра, то для него хорошо подойдет интеграция  на стороне сервера. При такой модели бэк будет собирать и отправлять пользователю всю html-разметку, необходимую для отрисовки страницы. Обновления будет происходить либо при полной перезагрузке страницы после получения новых данных с сервера, либо она будет обновляться по частям с помощью ajax. [Густав Нильсон Котте](https://twitter.com/gustaf_nk/) (Gustaff Nillson Kotte) написал [подробную статью](https://gustafnk.github.io/microservice-websites/) на эту тему.

Если же Ваш интерфейс должен мгновенно реагировать на действия пользователя, даже при нестабильном интернет-соединении, то сайт с рендерингом со стороны сервера для такой задачи неэффективен.
Для реализации таких штук как [Optimistic UI](https://www.smashingmagazine.com/2016/11/true-lies-of-optimistic-user-interfaces/) и [Skeleton Screens](https://www.lukew.com/ff/entry.asp?1797) Вам также нужна будет возможность обновлять UI на самом клиенте. Гугловское толкование [прогрессивного веб-приложения](https://web.dev/progressive-web-apps/) метко подчеркивает тот факт, что последнее, являясь “добропорядочным гражданином” веба ( благодаря прогрессивному улучшению), одновременно предоставляет пользователю опыт, схожий с тем, который он получает при работе с нативным приложением. PWA находятся примерно где-то посередине site-app-континуума. Здесь реализации, при которых многие задачи решаются исключительно на беке, уже не эффективны, и требуется большая интеграция в браузер. На этом и сфокусирована эта статья.

## Основные идеи микрофронтенда: ##
+ **Технологический агностицизм**  
Каждая команда должна иметь возможность выбирать и изменять свой стэк без необходимости координации с другими командами. Кастомные элементы хорошо подходят для одновременного сокрытия деталей реализации и предоставления нейтрального интерфейса для взаимодействия извне.
+ **Изоляция кода команды**  
Не делите рантайм с другими командами, даже если с ними со всеми работаете на одном фреймворке. Создавайте независимые, самодостаточные приложения. Не используете совместное с другими состояние или глобальные переменные.
+ **Установка префиксов для команд**  
Договоритесь о правилах нейминга там, где изоляция ещё не возможна ( CSS, события, local storage, cookies) для того, чтобы избежать коллизий и прояснить зоны ответственности.
+ **Предпочтение нативных браузерных API кастомным**
Используйте браузерные события для коммуникации(#) вместо того, чтобы глобально реализовывать паттерн издатель-подписчик  (PubSub). Если вам действительно нужно создавать API, с которым будут взаимодействовать несколько команд, старайтесь делать его как можно простым и таким сохранять.
+ **Создание устойчивого сайта**
От вашего приложения должен быть  толк даже если скрипты ещё не выполнились или выполнились с ошибкой. Используйте Universal Rendering(#) и прогрессивное улучшение для достижения лучшего поведения в подобных ситуациях.

## DOM - это API##
[Кастомные элементы](https://developers.google.com/web/fundamentals/web-components/customelements), отвечающие за функциональную совместимость по спецификации Веб-компонентов, являются хорошим инструментом для интеграции в браузере. Каждая команда создает свой компонент на тех технологиях, которые она выбрала, и оборачивает его в кастомный элемент (например, `<order-minicart></order-minicart>`). DOM-спецификация этого конкретного элемента выступает в роли контракта или публичного API для других команд. Это позволяет им использовать этот компонент и его функциональность, ничего не зная об её реализации. Им достаточно лишь  взаимодействовать с DOM-ом.

Но одно лишь использование кастомных элементов не является ответом на все вопросы. Для реализации прогрессивного улучшения, universal-рендеринга или роутинга нужно применять и другие решения.

Эта статья состоит их двух частей. В первой мы обсудим композицию страницы(#) - как выстраивать страницу из компонентов, которые разрабатывают разные команды. А затем мы рассмотрим примеры реализации перехода между страницами на клиенте.



