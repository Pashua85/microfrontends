# Микрофронтенды #
Распространение идеи микросервисов на фронтенд-разработку.
перевод [статьи Майкла Гирса](https://micro-frontends.org/)

Техники, стратегии и решения для разработки современных веб-приложений с участием нескольких команд, способных реализовывать фичи независимо друг от друга.

## Что такое микрофронтенды? ##
Термин микрофронтенды (Micro Frontends) впервые появился в конце 2016 года, на [радаре технологий ThoughtWorks](https://www.thoughtworks.com/radar/techniques/micro-frontends). Он расширял концепцию микросервисов на мир фронтенда. Сейчас уже популярен тренд, при котором single-page приложения взаимодействуют с бэком, построенном на принципах микросервисной архитектуры. При этом сам клиентский код, часто разрабатываемый отдельной командой, со временем всё больше разрастается и его становится трудно поддерживать. Именно его мы называем [монолитом фронтенда](https://www.youtube.com/watch?v=pU1gXA0rfwc&ab_channel=microXchg).

Идея микрофронтендов заключается в восприятии сайта или веб-приложения как композиции фичей, которые разрабатывают отдельные команды. Каждая команда имеет четко определенную зону ответственности в функционале приложения и специализируется на ней. При этом сами команды универсальны, работают full-stack и реализуют свои фичи end-to-end, от базы данных до пользовательского интерфейса.

Впрочем, эта идея не нова. Они имеет много общего с концепцией [автономных систем](https://scs-architecture.org/)(Self-contained Systems). Раньше аналогичный подход уже появлялся под названием [“клиентская интеграция для вертикализированных систем”](https://www.otto.de/jobs/technology/techblog/artikel/scaling-with-microservices-and-vertical-decomposition_2014-07-29.php) (Frontend Integration for Verticalised Systems). Однако термин микрофронтенды менее громоздкий и гораздо дружелюбней.

Монолитные фронтенды
![monolith-frontback-microservices](https://github.com/Pashua85/microfrontends/raw/master/assets/monolith-frontback-microservices.png)

Организация по вертикали
![verticals-headline](https://github.com/Pashua85/microfrontends/raw/master/assets/verticals-headline.png)

## Что такое современное веб-приложение? ##

Во вступлении я использовал фразу “разработка современных веб-приложений”. Давайте определимся, что мы под этим понятием подразумеваем.

[Эрал Бэлкон](https://ar.al/) (Aral Balcan) рассмотрел этот вопрос шире, написал отдельный пост под названием [Document-to-Application Contimuum](https://ar.al/notes/the-documents-to-applications-continuum/). Он выдвинул идею представления всего множества страниц в интернете в качестве нарисованного горизонтально отрезка со шкалой, на левом конце которого будут сайты, представляющие из себя статичные документы, соединенные друг с другом ссылками, а на другом - приложения без собственного контента, чье состояние полностью определяется поведением пользователя, например, онлайн-редактор фотографий.

Если бы вы разместили свой свой проект на левой стороне спектра, то для него хорошо подойдет интеграция  на стороне сервера. При такой модели бэк будет собирать и отправлять пользователю всю html-разметку, необходимую для отрисовки страницы. Обновления будет происходить либо при полной перезагрузке страницы после получения новых данных с сервера, либо она будет обновляться по частям с помощью ajax. [Густав Нильсон Котте](https://twitter.com/gustaf_nk/) (Gustaff Nillson Kotte) написал [подробную статью](https://gustafnk.github.io/microservice-websites/) на эту тему.

Если же Ваш интерфейс должен мгновенно реагировать на действия пользователя, даже при нестабильном интернет-соединении, то сайт с рендерингом со стороны сервера для такой задачи неэффективен.
Для реализации таких штук как [Optimistic UI](https://www.smashingmagazine.com/2016/11/true-lies-of-optimistic-user-interfaces/) и [Skeleton Screens](https://www.lukew.com/ff/entry.asp?1797) Вам также нужна будет возможность обновлять UI на самом клиенте. Гугловское толкование [прогрессивного веб-приложения](https://web.dev/progressive-web-apps/) метко подчеркивает тот факт, что последнее, являясь “добропорядочным гражданином” веба ( благодаря прогрессивному улучшению), одновременно предоставляет пользователю опыт, схожий с тем, который он получает при работе с нативным приложением. PWA находятся примерно где-то посередине site-app-континуума. Здесь реализации, при которых многие задачи решаются исключительно на беке, уже не эффективны, и требуется большая интеграция в браузер. На этом и сфокусирована эта статья.

## Основные идеи микрофронтенда: ##
+ **Технологический агностицизм**  
Каждая команда должна иметь возможность выбирать и изменять свой стэк без необходимости координации с другими командами. [Кастомные элементы](#customElements) хорошо подходят для одновременного сокрытия деталей реализации и предоставления нейтрального интерфейса для взаимодействия извне.
+ **Изоляция кода команды**  
Не делите рантайм с другими командами, даже если с ними со всеми работаете на одном фреймворке. Создавайте независимые, самодостаточные приложения. Не используете совместное с другими состояние или глобальные переменные.
+ **Установка префиксов для команд**  
Договоритесь о правилах нейминга там, где изоляция ещё не возможна ( CSS, события, local storage, cookies) для того, чтобы избежать коллизий и прояснить зоны ответственности.
+ **Предпочтение нативных браузерных API кастомным**  
Используйте [браузерные события для коммуникации](#browserEvents) вместо того, чтобы глобально реализовывать паттерн издатель-подписчик  (PubSub). Если вам действительно нужно создавать API, с которым будут взаимодействовать несколько команд, старайтесь делать его как можно простым и таким сохранять.
+ **Создание устойчивого сайта**  
От вашего приложения должен быть  толк даже если скрипты ещё не выполнились или выполнились с ошибкой. Используйте [Universal рендеринг](#universalRendering) и прогрессивное улучшение для достижения лучшего поведения в подобных ситуациях.

## DOM - это API ##
<a name="customElements"></a>[Кастомные элементы](https://developers.google.com/web/fundamentals/web-components/customelements), отвечающие за функциональную совместимость по спецификации Веб-компонентов, являются хорошим инструментом для интеграции в браузере. Каждая команда создает свой компонент на тех технологиях, которые она выбрала, и оборачивает его в кастомный элемент (например, `<order-minicart></order-minicart>`). DOM-спецификация этого конкретного элемента выступает в роли контракта или публичного API для других команд. Это позволяет им использовать этот компонент и его функциональность, ничего не зная об её реализации. Им достаточно лишь  взаимодействовать с DOM-ом.

Но одно лишь использование кастомных элементов не является ответом на все вопросы. Для реализации прогрессивного улучшения, universal-рендеринга или роутинга нужно применять и другие решения.

Эта статья состоит их двух частей. В первой мы обсудим композицию страницы(#) - как выстраивать страницу из компонентов, которые разрабатывают разные команды. А затем мы рассмотрим примеры реализации перехода между страницами на клиенте.

## Композиция страницы ##
Помимо непосредственно самой интеграции кода, написанного на разных фреймворках, будь то на клиенте или на сервере, необходимо обсудить ещё много смежных тем: механизмы изоляции js, избегания конфликтов css-стилей, подгрузка ресурсов по мере необходимости, использование одних и тех же ресурсов разными командами, загрузка данных и её реализация с точки зрения комфорта для пользователя. Мы поэтапно коснемся всех этих вопросов.

### Базовый прототип ###
Страничка с товаром онлайн-магазина моделей тракторов послужит основой для последующих примеров.

На ней есть селектор для выбора между тремя вариантами моделей. При изменении выбранной модели обновляется изображение на странице, а также цена, название и рекомендации. Есть ещё кнопка покупки, которая добавляет выбранный товар в корзину и мини-корзина вверху странички, которая после этого действия обновляется.

![model-store-0](https://github.com/Pashua85/microfrontends/raw/master/assets/model-store-0.gif)

[посмотрите, как это работает в браузере](https://micro-frontends.org/0-model-store/) и [загляните в код](https://github.com/neuland/micro-frontends/tree/master/0-model-store)

Вся разметка генерируется на клиенте на основе ванильного JS, без каких-либо зависимостей. В коде работа с состоянием отделена от генерации разметки, весь HTML заново перерисовывается каждый раз при изменении состояния - пока никаких затейливых манипуляций с DOM или universal-рендеринга нет. Также отсутствует еще разделение  зон ответственности в работе над приложение между командами - весь [код](https://github.com/neuland/micro-frontends/tree/master/0-model-store) написан в одном файле.

### Интеграция на клиенте ###
В следующем примере, страница уже поделена на отдельные компоненты, которые разрабатывают три разные команды. Команда Checkout (синие) ответственна для всё, что связано с процессом покупки - собственно кнопка покупки и мини-корзина. Команда Inspire (зеленые) управляет блоком рекомендаций товаров на странице. Сама же страница разрабатывается командой Product (красные).

![three-teams](https://github.com/Pashua85/microfrontends/raw/master/assets/three-teams.png)

[посмотрите, как это работает в браузере](https://micro-frontends.org/1-composition-client-only/) и [загляните в код](https://github.com/neuland/micro-frontends/tree/master/1-composition-client-only)

Команда Product решает какую функциональность добавлять к карточке товара и где именно её размещать. Сама страница включает информацию о продукте, поступающую от одноименной команды - название товара, его изображение, доступные варианты моделей. Также она содержит фрагменты (кастомные элементы) от других команд.

### Как создать кастомный элемент? ###
Возьмем для примера кнопку покупки. Команда Product использует её, просто добавляя (`<blue-buy sku="t_porsche"></blue-buy>`) в нужное место в разметке. Для того, чтобы это работало, нужно, чтобы команда Checkout зарегистрировала
элемент `blue-buy` на странице.

    class BlueBuy extends HTMLElement {
      connectedCallback() {
        this.innerHTML = `<button type="button">buy for 66,00 €</button>`;
      }

      disconnectedCallback() { ... }
    }
    window.customElements.define('blue-buy', BlueBuy);

Каждый раз, когда браузеру при отрисовке разметки попадается тег `<blue-buy>`, вызывается метод `connectedCallback`. `this` ссылается на корневой DOM-узел кастомного элемента. Также можно использовать все свойства и методы стандартного DOM-элемента, например `innerHeight` или `getAttribute()`.

![custom-element](https://github.com/Pashua85/microfrontends/raw/master/assets/custom-element.gif)

Что касается нейминга кастомных элементов, то единственным требованием для этого, согласно спецификации, является использование дефиса (-) для обеспечения совместимости с новыми HTML тегами, которые появятся в будущем.
В следующих примерах используется формат `[цвет_команды]-[фичи]`. Присутствие в названии элемента имени команды защищает от возможных конфликтов, а также дает возможность понять, кто за что отвечает, просто взглянув на DOM.

### Взаимодействие родитель-дочерний элемент / манипуляции с DOMом. ###
<a name="browserEvents"></a>Когда пользователь выбирает другую модель трактора, кнопка покупки должна соответствующим образом обновиться. Для этого команда Product может просто удалить существующий элемент из DOMа и добавить новый.

    container.innerHTML;
    // => <blue-buy sku="t_porsche">...</blue-buy>
    container.innerHTML = '<blue-buy sku="t_fendt"></blue-buy>';

Метод `disconnectedCallback` вызывается синхронно перед удалением старого элемента для того, чтобы за ним подчистить, например удалить обработчики событий. Затем вызывается метод `connectedCallback` только что созданного `t_fendt` элемента.

Другой способ, более эффективный с точки зрения производительности, заключается в обновления только sku атрибута существующего элемента (stock keeping unit - идентификатор товарной позиции).

    document.querySelector('blue-buy').setAttribute('sku', 't_fendt');

Если команда Product использовала бы какой-нибудь шаблонный движок, обновляющий DOM, наподобие React, то следующее будет происходить автоматически:

![custom-element-attribute](https://github.com/Pashua85/microfrontends/raw/master/assets/custom-element-attribute.gif)

В нашем же кастомном элементе это будет реализовано с помощью `attributeChangedCallback` и определения списка `observedAttributes`, для которых этот коллбэк будет вызываться.

    const prices = {
      t_porsche: '66,00 €',
      t_fendt: '54,00 €',
      t_eicher: '58,00 €',
    };

    class BlueBuy extends HTMLElement {
      static get observedAttributes() {
        return ['sku'];
      }
      connectedCallback() {
        this.render();
      }
      render() {
        const sku = this.getAttribute('sku');
        const price = prices[sku];
        this.innerHTML = `<button type="button">buy for ${price}</button>`;
      }
      attributeChangedCallback(attr, oldValue, newValue) {
        this.render();
      }
      disconnectedCallback() {...}
    }
    window.customElements.define('blue-buy', BlueBuy);

Для избежания дублирования логики создан отдельный метод `render()`, который вызывается и из `connectedCallback`, и из `attributeChangedCallback`. Этот метод получает необходимые данные и определяет новую разметку. Если бы решено было использовать более сложный шаблонный движок или какой-нибудь фреймворк, то включать его в код нужно было бы именно в этом месте.

### Поддержка браузеров  ###
Пример выше использует спецификацию Custom Element V1, которую сейчас [поддерживают Chrome, Safari и Opera](https://caniuse.com/custom-elementsv1). Но с легковесным и уже хорошо протестированным полифилом [document-register-element](https://github.com/WebReflection/document-register-element) это будет работать во всех браузерах. Этот полифил под капотом использует [широко поддерживаемый](https://caniuse.com/mutationobserver) Mutation Observer API.

### Совместимость с фреймворками ###
Поскольку кастомные элементы являются стандартом для веба, все основные фреймворки для фронта вроде Angular, React, Preact, Vue или Hyperapp их поддерживают. Тем не менее, когда дело доходит до некоторых нюансов, в работе с некоторыми из этих фреймворков все еще можно столкнуться с определенными проблемами. [Роб Додсон](https://twitter.com/rob_dodson)(Rob Dodson) на [CustomElementsEverywhere](https://custom-elements-everywhere.com/) собрал наборы тестов совместимости, которые указывают на еще нерешенные вопросы.

### Коммуникация между родительскими элементами и потомками, а также между соседними элементами / События DOM ###
Но не для каждого взаимодействия на странице обновление атрибутов является оптимальным способом реализации. В нашем примере мини-корзина должна обновляться каждый раз, когда пользователь кликает по кнопке покупки.

Оба этих фрагмента интерфейса разрабатываются командой Checkout (синие), поэтому последняя могла бы создать своего рода внутренний Javascript API, позволяющий корзине быть осведомленной о клике по кнопке. Но это потребовало бы того, чтобы эти сущности знали друг о друге, что является нарушением изоляции компонентов.

Более чистым способом реализации будет использование паттерна Издатель-Подписчик, при котором один компонент может отправлять сообщения, а другие компоненты могут подписаться на их получение. К счастью, в браузерах есть все этого есть. Именно благодаря этому мы работаем с событиями вроде `click`, `select` или `mouseOver`. Помимо нативных событий можно ещё создать кастомные события с помощью `new CustomEvent(...)`. События всегда связаны с тем DOM узлом, где они возникли. Большинство нативных событий также подразумевает всплытие. Это дает возможность слушать все события на определенной ветке DOM дерева. Если вам нужно реагировать на все события на странице, добавьте обработчик событий на объект window. Вот как создание события `blue:basket:changed` выглядит в примере:

    class BlueBuy extends HTMLElement {
      [...]
      connectedCallback() {
        [...]
        this.render();
        this.firstChild.addEventListener('click', this.addToCart);
      }
      addToCart() {
        // maybe talk to an api
        this.dispatchEvent(new CustomEvent('blue:basket:changed', {
          bubbles: true,
        }));
      }
      render() {
        this.innerHTML = `<button type="button">buy</button>`;
      }
      disconnectedCallback() {
        this.firstChild.removeEventListener('click', this.addToCart);
      }
    }

Мини-корзина теперь может подписаться на это событие на `window`и получать уведомления всякий раз, когда ей нужно обновить свои данные.

    class BlueBasket extends HTMLElement {
      connectedCallback() {
        [...]
        window.addEventListener('blue:basket:changed', this.refresh);
      }
      refresh() {
        // fetch new data and render it
      }
      disconnectedCallback() {
        window.removeEventListener('blue:basket:changed', this.refresh);
      }
    }

При этом мини-корзина добавляет обработчик события на тот элемент DOM, который находится вне её (`window`). Это вполне будет хорошо работать в большинстве приложений, но если вам этот подход некомфортен, то можете использовать другой -  пусть сама страница (команда Product) слушает событие и вызывает метод `refresh` у DOM элемента корзины.

    // page.js
    const $ = document.getElementsByTagName;

    $('blue-buy')[0].addEventListener('blue:basket:changed', function() {
      $('blue-basket')[0].refresh();
    });

Вызов методов у DOM элементов соответствует императивному стилю программирования и довольно редко применяется, однако его можно встретить, например, в [video element api](https://developer.mozilla.org/de/docs/Web/HTML/Using_HTML5_audio_and_video#Controlling_media_playback). Если возможно придерживаться декладекларотивного стиля (изменение атрибутов) - то лучше придерживаться его.

## Рендеринг на стороне сервера / Unuversal рендеринг ##
<a name="universalRendering"></a>Кастомные элементы прекрасно подходят для интеграции компонентов в браузере. Но когда мы создаем сайт, доступный в вебе, то часто возникает вопрос   производительности при первоначальной загрузке и необходимость устранения того, что пользователь будет видеть белый экран до тех пор, пока все скрипты, с помощью которых фреймворки строят страницу, не загрузятся и не исполнятся. Вдобавок, хорошо бы подумать о том, что будет с сайтом, если скрипты заблокированы или фэйлятся при загрузке. [Джереми Кейт](https://adactio.com/)(Jeremy Keith) объясняет важность этого в своем подкасте/ebook [Устойчивый веб дизайн](https://resilientwebdesign.com/). Ключом к решению этих задач является рендеринг базового контента на сервере. К сожалению, в спецификации веб-компонентов совершенно ничего не сказано о рендеринге на стороне сервера.
