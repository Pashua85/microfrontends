# Микрофронтенды #
Распространение идеи микросервисов на фронтенд-разработку.
перевод [статьи Майкла Гирса](https://micro-frontends.org/)

Техники, стратегии и решения для разработки современных веб-приложений с участием нескольких команд, способных реализовывать фичи независимо друг от друга.

## Что такое микрофронтенды? ##
Термин микрофронтенды (Micro Frontends) впервые появился в конце 2016 года на [радаре технологий ThoughtWorks](https://www.thoughtworks.com/radar/techniques/micro-frontends). Он расширял концепцию микросервисов на мир фронтенда. Сейчас уже популярен тренд, при котором одностраничные приложения взаимодействуют с бэком, построенном на принципах микросервисной архитектуры. При этом сам клиентский код, часто разрабатываемый отдельной командой, со временем всё больше разрастается, и его становится трудно поддерживать. Именно это мы называем [монолитом фронтенда](https://www.youtube.com/watch?v=pU1gXA0rfwc&ab_channel=microXchg).

Идея микрофронтендов заключается в восприятии сайта или веб-приложения как композиции фичей, которые разрабатывают отдельные команды. Каждая команда имеет четко определенную зону ответственности в функционале приложения и специализируется на ней. При этом сами команды универсальны, работают full-stack и реализуют свои фичи end-to-end, от базы данных до пользовательского интерфейса.

Впрочем, эта идея не нова. Они имеет много общего с концепцией [автономных систем](https://scs-architecture.org/)(Self-contained Systems). Раньше аналогичный подход уже появлялся под названием [“клиентская интеграция для вертикализированных систем”](https://www.otto.de/jobs/technology/techblog/artikel/scaling-with-microservices-and-vertical-decomposition_2014-07-29.php) (Frontend Integration for Verticalised Systems). Однако термин микрофронтенды менее громоздкий и гораздо дружелюбней.

Монолитные фронтенды
![monolith-frontback-microservices](https://github.com/Pashua85/microfrontends/raw/master/assets/monolith-frontback-microservices.png)

Организация по вертикали
![verticals-headline](https://github.com/Pashua85/microfrontends/raw/master/assets/verticals-headline.png)

## Что такое современное веб-приложение? ##

Во вступлении я использовал фразу “разработка современных веб-приложений”. Давайте определимся, что мы под этим понятием подразумеваем.

[Эрал Бэлкон](https://ar.al/) (Aral Balcan) рассмотрел этот вопрос шире, написал отдельный пост под названием [Document-to-Application Contimuum](https://ar.al/notes/the-documents-to-applications-continuum/). Он выдвинул идею представления всего множества страниц в интернете в качестве нарисованного горизонтально отрезка со шкалой, на левом конце которого будут сайты, представляющие из себя статичные документы, соединенные друг с другом ссылками, а на другом - приложения без собственного контента, чье состояние полностью определяется поведением пользователя, например, онлайн-редактор фотографий.

Если бы вы разместили свой проект на левой стороне спектра, то для него хорошо подойдет интеграция  на стороне сервера. При такой модели бэк будет собирать и отправлять пользователю всю html-разметку, необходимую для отрисовки страницы. Обновления будет происходить либо при полной перезагрузке страницы после получения новых данных с сервера, либо она будет обновляться по частям с помощью ajax. [Густав Нильсон Котте](https://twitter.com/gustaf_nk/) (Gustaff Nillson Kotte) написал [подробную статью](https://gustafnk.github.io/microservice-websites/) на эту тему.

Если же Ваш интерфейс должен мгновенно реагировать на действия пользователя, даже при нестабильном интернет-соединении, то сайт с рендерингом со стороны сервера для такой задачи неэффективен.
Для реализации таких штук как [Optimistic UI](https://www.smashingmagazine.com/2016/11/true-lies-of-optimistic-user-interfaces/) и [Skeleton Screens](https://www.lukew.com/ff/entry.asp?1797) Вам также нужна будет возможность обновлять UI на самом клиенте. Гугловское толкование [прогрессивного веб-приложения](https://web.dev/progressive-web-apps/) метко подчеркивает тот факт, что последнее, являясь “добропорядочным гражданином” веба ( благодаря прогрессивному улучшению), одновременно предоставляет пользователю опыт, схожий с тем, который он получает при работе с нативным приложением. PWA находятся примерно где-то посередине site-app-континуума. Здесь реализации, при которых многие задачи решаются исключительно на беке, уже неэффективны, и требуется большая интеграция в браузере. На этом и сфокусирована эта статья.

## Основные идеи микрофронтенда: ##
+ **Технологический агностицизм**  
Каждая команда должна иметь возможность выбирать и изменять свой стэк без необходимости координации с другими командами. [Кастомные элементы](#customElements) хорошо подходят для одновременного сокрытия деталей реализации и предоставления нейтрального интерфейса для взаимодействия извне.
+ **Изоляция кода команды**  
Не делите рантайм с другими командами, даже если вы все работаете на одном фреймворке. Создавайте независимые, самодостаточные приложения. Не используете совместное с другими командами состояние или глобальные переменные.
+ **Установка префиксов для команд**  
Договоритесь о правилах нейминга там, где изоляция ещё не возможна ( CSS, события, local storage, cookies) для того, чтобы избежать коллизий и прояснить зоны ответственности.
+ **Предпочтение нативных браузерных API кастомным**  
Используйте [браузерные события для коммуникации](#browserEvents) вместо того, чтобы глобально реализовывать паттерн издатель-подписчик  (PubSub). Если вам действительно нужно создавать API, с которым будут взаимодействовать несколько команд, старайтесь делать его как можно простым и таким и сохраняйте.
+ **Создание устойчивого сайта**  
От вашего приложения должен быть  толк даже если скрипты ещё не выполнились или выполнились с ошибкой. Используйте [Universal рендеринг](#universalRendering) и прогрессивное улучшение для достижения лучшего поведения в подобных ситуациях.

<a name="customElements"></a>
## DOM - это API ##
[Кастомные элементы](https://developers.google.com/web/fundamentals/web-components/customelements), отвечающие за функциональную совместимость по спецификации Веб-компонентов, являются хорошим инструментом для интеграции в браузере. Каждая команда создает свой компонент на тех технологиях, которые она выбрала, и оборачивает его в кастомный элемент (например, `<order-minicart></order-minicart>`). DOM-спецификация этого конкретного элемента выступает в роли контракта или публичного API для других команд. Это позволяет им использовать этот компонент и его функциональность, ничего не зная об её реализации. Им достаточно лишь  взаимодействовать с DOM-ом.

Но одно лишь использование кастомных элементов не является ответом на все вопросы. Для реализации прогрессивного улучшения, universal-рендеринга или роутинга нужно применять и другие решения.

Эта статья состоит их двух частей. В первой мы обсудим композицию страницы - как выстраивать страницу из компонентов, которые разрабатывают разные команды. А затем мы рассмотрим примеры реализации перехода между страницами на клиенте.

## Композиция страницы ##
Помимо непосредственно самой интеграции кода, написанного на разных фреймворках, будь то на клиенте или на сервере, необходимо обсудить ещё много смежных тем: механизмы изоляции js, избегания конфликтов css-стилей, подгрузка ресурсов по мере необходимости, использование одних и тех же ресурсов разными командами, загрузка данных и её реализация с точки зрения комфорта для пользователя. Мы поэтапно коснемся всех этих вопросов.

### Базовый прототип ###
Страничка с товаром онлайн-магазина моделей тракторов послужит основой для последующих примеров.

На ней есть селектор для выбора между тремя вариантами моделей. При изменении выбранной модели обновляется изображение на странице, а также цена, название и рекомендации. Есть ещё кнопка покупки, которая добавляет выбранный товар в корзину и мини-корзина вверху странички, которая после этого действия обновляется.

![model-store-0](https://github.com/Pashua85/microfrontends/raw/master/assets/model-store-0.gif)

[посмотрите, как это работает в браузере](https://micro-frontends.org/0-model-store/) и [загляните в код](https://github.com/neuland/micro-frontends/tree/master/0-model-store)

Вся разметка генерируется на клиенте на основе ванильного JS, без каких-либо зависимостей. В коде работа с состоянием отделена от генерации разметки, весь HTML заново перерисовывается каждый раз при изменении состояния - пока никаких затейливых манипуляций с DOM или universal-рендеринга нет. Также отсутствует еще разделение  зон ответственности в работе над приложение между командами - весь [код](https://github.com/neuland/micro-frontends/tree/master/0-model-store) написан в одном файле.

### Интеграция на клиенте ###
В следующем примере, страница уже поделена на отдельные компоненты, которые разрабатывают три разные команды. Команда Checkout (синие) ответственна для всё, что связано с процессом покупки - собственно кнопка покупки и мини-корзина. Команда Inspire (зеленые) управляет блоком рекомендаций товаров на странице. Сама же страница разрабатывается командой Product (красные).

![three-teams](https://github.com/Pashua85/microfrontends/raw/master/assets/three-teams.png)

[посмотрите, как это работает в браузере](https://micro-frontends.org/1-composition-client-only/) и [загляните в код](https://github.com/neuland/micro-frontends/tree/master/1-composition-client-only)

Команда Product решает какую функциональность добавлять к карточке товара и где именно её размещать. Сама страница включает информацию о продукте, поступающую от одноименной команды - название товара, его изображение, доступные варианты моделей. Также она содержит фрагменты (кастомные элементы) от других команд.

### Как создать кастомный элемент? ###
Возьмем для примера кнопку покупки. Команда Product использует её, просто добавляя `<blue-buy sku="t_porsche"></blue-buy>` в нужное место в разметке. Для того, чтобы это работало, нужно, чтобы команда Checkout зарегистрировала
элемент `blue-buy` на странице.

    class BlueBuy extends HTMLElement {
      connectedCallback() {
        this.innerHTML = `<button type="button">buy for 66,00 €</button>`;
      }

      disconnectedCallback() { ... }
    }
    window.customElements.define('blue-buy', BlueBuy);

Каждый раз, когда браузеру при отрисовке разметки попадается тег `<blue-buy>`, вызывается метод `connectedCallback`. `this` ссылается на корневой DOM-узел кастомного элемента. Также можно использовать все свойства и методы стандартного DOM-элемента, например `innerHeight` или `getAttribute()`.

![custom-element](https://github.com/Pashua85/microfrontends/raw/master/assets/custom-element.gif)

Что касается нейминга кастомных элементов, то единственным требованием для этого, согласно спецификации, является использование дефиса (-) для обеспечения совместимости с новыми HTML тегами, которые появятся в будущем.
В следующих примерах используется формат `[цвет_команды]-[фичи]`. Присутствие в названии элемента имени команды защищает от возможных конфликтов, а также дает возможность понять, кто за что отвечает, просто взглянув на DOM.

<a name="browserEvents"></a>
### Взаимодействие родитель - дочерний элемент / манипуляции с DOMом. ###
Когда пользователь выбирает другую модель трактора, кнопка покупки должна соответствующим образом обновиться. Для этого команда Product может просто удалить существующий элемент из DOMа и добавить новый.

    container.innerHTML;
    // => <blue-buy sku="t_porsche">...</blue-buy>
    container.innerHTML = '<blue-buy sku="t_fendt"></blue-buy>';

Метод `disconnectedCallback` вызывается синхронно перед удалением старого элемента для того, чтобы за ним подчистить, например удалить обработчики событий. Затем вызывается метод `connectedCallback` только что созданного `t_fendt` элемента.

Другой способ, более эффективный с точки зрения производительности, заключается в обновления только sku атрибута существующего элемента (stock keeping unit - идентификатор товарной позиции).

    document.querySelector('blue-buy').setAttribute('sku', 't_fendt');

Если команда Product использовала бы какой-нибудь шаблонный движок, обновляющий DOM, наподобие React, то следующее будет происходить автоматически:

![custom-element-attribute](https://github.com/Pashua85/microfrontends/raw/master/assets/custom-element-attribute.gif)

В нашем же кастомном элементе это будет реализовано с помощью `attributeChangedCallback` и определения списка `observedAttributes`, для которых этот коллбэк будет вызываться.

    const prices = {
      t_porsche: '66,00 €',
      t_fendt: '54,00 €',
      t_eicher: '58,00 €',
    };

    class BlueBuy extends HTMLElement {
      static get observedAttributes() {
        return ['sku'];
      }
      connectedCallback() {
        this.render();
      }
      render() {
        const sku = this.getAttribute('sku');
        const price = prices[sku];
        this.innerHTML = `<button type="button">buy for ${price}</button>`;
      }
      attributeChangedCallback(attr, oldValue, newValue) {
        this.render();
      }
      disconnectedCallback() {...}
    }
    window.customElements.define('blue-buy', BlueBuy);

Для избежания дублирования логики создан отдельный метод `render()`, который вызывается и из `connectedCallback`, и из `attributeChangedCallback`. Этот метод получает необходимые данные и определяет новую разметку. Если бы решено было использовать более сложный шаблонный движок или какой-нибудь фреймворк, то включать его в код нужно было бы именно в этом месте.

### Поддержка браузеров  ###
Пример выше использует спецификацию Custom Element V1, которую сейчас [поддерживают Chrome, Safari и Opera](https://caniuse.com/custom-elementsv1). Но с легковесным и уже хорошо протестированным полифилом [document-register-element](https://github.com/WebReflection/document-register-element) это будет работать во всех браузерах. Этот полифил под капотом использует [широко поддерживаемый](https://caniuse.com/mutationobserver) Mutation Observer API.

### Совместимость с фреймворками ###
Поскольку кастомные элементы являются стандартом для веба, все основные фреймворки для фронта вроде Angular, React, Preact, Vue или Hyperapp их поддерживают. Тем не менее, когда дело доходит до некоторых нюансов, в работе с некоторыми из этих фреймворков все еще можно столкнуться с определенными проблемами. [Роб Додсон](https://twitter.com/rob_dodson)(Rob Dodson) на [CustomElementsEverywhere](https://custom-elements-everywhere.com/) собрал наборы тестов совместимости, которые указывают на еще нерешенные вопросы.

### Коммуникация между родительскими элементами и потомками, а также между соседними элементами / События DOM ###
Но не для каждого взаимодействия на странице обновление атрибутов является оптимальным способом реализации. В нашем примере мини-корзина должна обновляться каждый раз, когда пользователь кликает по кнопке покупки.

Оба этих фрагмента интерфейса разрабатываются командой Checkout (синие), поэтому последняя могла бы создать своего рода внутренний Javascript API, позволяющий корзине быть осведомленной о клике по кнопке. Но это потребовало бы того, чтобы эти сущности знали друг о друге, что является нарушением изоляции компонентов.

Более чистым способом реализации будет использование паттерна Издатель-Подписчик, при котором один компонент может отправлять сообщения, а другие компоненты могут подписаться на их получение. К счастью, в браузерах все для этого есть. Именно благодаря этому мы работаем с событиями вроде `click`, `select` или `mouseOver`. Помимо нативных событий можно ещё создать кастомные события с помощью `new CustomEvent(...)`. События всегда связаны с тем DOM узлом, где они возникли. Большинство нативных событий также подразумевает всплытие. Это дает возможность слушать все события на определенной ветке DOM дерева. Если вам нужно реагировать на все события на странице, добавьте обработчик событий на объект window. Вот как создание события `blue:basket:changed` выглядит в примере:

    class BlueBuy extends HTMLElement {
      [...]
      connectedCallback() {
        [...]
        this.render();
        this.firstChild.addEventListener('click', this.addToCart);
      }
      addToCart() {
        // maybe talk to an api
        this.dispatchEvent(new CustomEvent('blue:basket:changed', {
          bubbles: true,
        }));
      }
      render() {
        this.innerHTML = `<button type="button">buy</button>`;
      }
      disconnectedCallback() {
        this.firstChild.removeEventListener('click', this.addToCart);
      }
    }

Мини-корзина теперь может подписаться на это событие на `window`и получать уведомления всякий раз, когда ей нужно обновить свои данные.

    class BlueBasket extends HTMLElement {
      connectedCallback() {
        [...]
        window.addEventListener('blue:basket:changed', this.refresh);
      }
      refresh() {
        // fetch new data and render it
      }
      disconnectedCallback() {
        window.removeEventListener('blue:basket:changed', this.refresh);
      }
    }

При этом мини-корзина добавляет обработчик события на тот элемент DOM, который находится вне её (`window`). Это вполне будет хорошо работать в большинстве приложений, но если вам этот подход некомфортен, то можете использовать другой -  пусть сама страница (команда Product) слушает событие и вызывает метод `refresh` у DOM элемента корзины.

    // page.js
    const $ = document.getElementsByTagName;

    $('blue-buy')[0].addEventListener('blue:basket:changed', function() {
      $('blue-basket')[0].refresh();
    });

Вызов методов у DOM элементов соответствует императивному стилю программирования и довольно редко применяется, однако его можно встретить, например, в [video element api](https://developer.mozilla.org/de/docs/Web/HTML/Using_HTML5_audio_and_video#Controlling_media_playback). Если возможно придерживаться декладекларотивного стиля (изменение атрибутов) - то лучше придерживаться его.

<a name="universalRendering"></a>
### Рендеринг на стороне сервера / Unuversal рендеринг 
Кастомные элементы прекрасно подходят для интеграции компонентов в браузере. Но когда мы создаем сайт, доступный в вебе, то часто возникает вопрос   производительности при первоначальной загрузке и необходимость устранения того, что пользователь будет видеть белый экран до тех пор, пока все скрипты, с помощью которых фреймворки строят страницу, не загрузятся и не исполнятся. Вдобавок, хорошо бы подумать о том, что будет с сайтом, если скрипты заблокированы или фэйлятся при загрузке. [Джереми Кейт](https://adactio.com/)(Jeremy Keith) объясняет важность этого в своем подкасте/ebook [Устойчивый веб дизайн](https://resilientwebdesign.com/). Ключом к решению этих задач является рендеринг базового контента на сервере. К сожалению, в спецификации веб-компонентов совершенно ничего не сказано о рендеринге на стороне сервера.

### Custom Elements + Server Side Includes = ❤️
Для того, чтобы рендеринг на стороне сервера заработал, нужно отрефакторить предыдущий пример. У каждой команды есть свой express сервер и метод `render()` кастомного элемента также доступен через url

    $ curl http://127.0.0.1:3000/blue-buy?sku=t_porsche
    <button type="button">buy for 66,00 €</button>

Название кастомного элемента используется в качестве названия пути - атрибуты становятся параметрами запроса. Теперь становится возможным рендерить на сервере контент каждого компонента. В комбинации с тегом `<blue-buy>` достигается что-то близкое к Universal Web Component:

    <blue-buy sku="t_porsche">
      <!--#include virtual="/blue-buy?sku=t_porsche" -->
    </blue-buy>

`#includes`-комментарий является частью  [Server Side Includes](https://en.wikipedia.org/wiki/Server_Side_Includes), фичи, которая доступна на большинстве веб-серверов. И да, это та самая техника, которая давным-давно использовалась для того, чтобы вставить актуальную дату на ваш сайт. Существуют и альтернативные способы, вроде [ESI](https://en.wikipedia.org/wiki/Edge_Side_Includes), [nodesi](https://github.com/Schibsted-Tech-Polska/nodesi), [compoxure](https://github.com/tes/compoxure) или [taylor](https://github.com/zalando/tailor), но для наших проектов SSI зарекомендовал себя как простое и чрезвычайно стабильное решение.

Комментарий c `#include` перед тем, как сервер отправит всю страницу на клиент, заменяется на ответ на запрос `/blue-buy?sku=t_porsche`. Конфигурация nginx выглядит так:

    upstream team_blue {
      server team_blue:3001;
    }
    upstream team_green {
      server team_green:3002;
    }
    upstream team_red {
      server team_red:3003;
    }

    server {
      listen 3000;
      ssi on;

      location /blue {
        proxy_pass  http://team_blue;
      }
      location /green {
        proxy_pass  http://team_green;
      }
      location /red {
        proxy_pass  http://team_red;
      }
      location / {
        proxy_pass  http://team_red;
      }
    }

Директива `ssi: on;` позволяет работать с SSI, а блоки `upstream` и `location` обеспечивают корректный роутинг для url-ссылок, например url, начинающийся на `/blue` будет работать с `team_blue:3001`. Кроме того, корневой путь `/` завязан на команде красных, отвечающей за продукт и страницу в целом.

Эта анимация показывает магазин моделей тракторов в браузере с отключенным Javascript :

![server-render](https://github.com/Pashua85/microfrontends/raw/master/assets/server-render.gif)

[посмотреть код](https://github.com/neuland/micro-frontends/tree/master/2-composition-universal)

Селекторы для выбора вариантов сейчас фактически являются ссылками и каждый клик по ним ведет к перезагрузке страницы. В терминале справа видно, как запрос сначала попадает к красной команде, отвечающей за страницу продукта, а затем в разметку добавляются фрагменты от синей и зеленой команд.

Если обратно включить Javascript, то будут видны логи только первого запроса.
Все последующие изменения моделей тракторов будут обрабатываться только на клиенте, точно так же, как и в первом примере. В последующем примере данные о продукте будут удалены из скрипта страницы и будут загружаться, как и положено, через REST api.

Вы можете поиграть с примером на локальной машине. Для этого только нужно установить [DockerCompose](https://docs.docker.com/compose/install/)

    git clone https://github.com/neuland/micro-frontends.git
    cd micro-frontends/2-composition-universal
    docker-compose up --build

Docker стартанет с nginx на порте 3000 и создаст nodejs образы для каждой команды. Если вы откроете http://127.0.0.1:3000/ в вашем браузере, то вы увидите красный трактор. Логи, выводимые `docker-compose`, позволяют легко увидеть, что происходит в сети. К сожалению невозможно контролировать цвет вывода, так что придется свыкнуться с тем, что сообщения о синей команде могут быть зелеными :)

Файлы, указанные в `src` атрибутах, размещены в индивидуальных контейнерах, и node приложение будет перезапускаться каждый раз, как вы измените код. Изменение же `nginx.conf` требует рестарта `docker-compose`. Так что можете побаловаться с кодом демки и дать обратную связь.

### Подтягивание данных и состояния загрузки.
Недостатком использования SSI/ESI является то, что скорость отклика всей страницы определяется самым медленным ее фрагментом. Поэтому, хорошо бы кешировать ответ фрагмента. Если же фрагменты достаточно ресурсоемкие для отрисовки и не подходят для кеширования, то зачастую лучше их исключить из первоначального рендеринга. Они могут быть загружены на клиент асинхронно.
В нашем примере для этого хорошо подойдет фрагмент `green-recos`, отображающий персональные рекомендации.

Одно из решений может заключаться в том, что команда красных просто уберет SSI Include.

До

    <green-recos sku="t_porsche">
      <!--#include virtual="/green-recos?sku=t_porsche" -->
    </green-recos>

После

    <green-recos sku="t_porsche"></green-recos>

*Важное примечание*: кастомные элементы [не могут быть самозакрывающимися](https://developers.google.com/web/fundamentals/web-components/customelements#jsapi), поэтому использование `<green-recos sku=”t_porsche” />` не будет корректно работать.

![data-fetching-reflow](https://github.com/Pashua85/microfrontends/raw/master/assets/data-fetching-reflow.gif)

Рендеринг этого блока теперь происходит только на клиенте. Однако, как вы можете видеть по анимации, он вызывает значительные перерасчеты размеров на странице. Сам блок рекомендаций изначально пуст. Затем скачиваются и исполняются скрипты от команды зеленых. Вызывается API для загрузки персональных рекомендаций. Рисуется их разметка и запрашиваются необходимы для неё картинки. Теперь фрагменту нужно больше места, и он двигает разметку всей страницы.

Существует несколько способов избежать этого. Команда красных, управляющая страницей, могла бы зафиксировать высоту блока рекомендаций. На отзывчивых сайтах часто нелегко определить высоту, поскольку она может меняться на разных экранах. Но главная сложность этого подхода не в этом, а в том, что он вынуждает команды координировать свои действия. Если команда зеленых захочет добавить подзаголовок к рекомендациям, она должна договориться с командой красных о новой высоте. И обе команды должны выкатывать свои изменения одновременно,
чтобы не сломать верстку страницы.

Лучшим решением будет использование техники так называемых [каркасных экранов](https://blog.prototypr.io/luke-wroblewski-introduced-skeleton-screens-in-2013-through-his-work-on-the-polar-app-later-fd1d32a6a8e7) (Skeleton Screens). Команда красных оставляет для `green-recos` SSI Includes в разметке. А команда зеленых изменяет метод render на сервере таким образом, что он создает схематичную версию контента. Каркас разметки может использовать некоторые стили из реального лейаута. Таким образом, он резервирует необходимое место на странице, и наполнение блока контентом не приводил к “подпрыгиванию” элементов на экране.

![data-fetching-skeleton](https://github.com/Pashua85/microfrontends/raw/master/assets/data-fetching-skeleton.gif)

Каркасные экраны также очень полезны для рендеринга на клиенте. Когда кастомный элемент включается в DOM в ответ на определенные действия пользователя, он может мгновенно отображать свой каркас, пока с сервера не придут нужные данные для полной отрисовки.

Вы можете даже использовать каркасный вид при смене атрибутов, пока нужные данные не подгрузятся, например, при смене селектора моделей. Таким образом, пользователь будет видеть, что с фрагментом что-то происходит. Впрочем, если ответ на запрос приходит быстро, короткое мерцание каркаса между отображениями старых и новых данных могут только раздражать. Сохранение старого отображения или умно использованные таймеры могут помочь. Так что используйте эту технику грамотно и постарайтесь получить обратную связь от пользователя.

## Навигация между страницами
продолжение следует

[следите за репозиторием](https://github.com/neuland/micro-frontends)